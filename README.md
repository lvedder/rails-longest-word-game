# README
Specs
Let's think about the UI for our game. What do we need?

A page to display the game settings (random letters), with a form for the user to type a word. A button to submit this form.
A page receiving this form, computing the user score and displaying it.

1 - Routing & Controller
Using the right command line command, generate the GamesController with two actions new and score. The new action will be used to display a new random grid and a form. The form will be submitted (with POST) to the score action.

Open you routes.rb file and tweak the routes automatically generated by the previous command. In the end, rails routes should return something like this:

Prefix Verb URI Pattern      Controller#Action
   new GET  /new(.:format)   games#new
 score POST /score(.:format) games#score
 
2 - Generating a new game
Have a look at your old Ruby code. How did you generate an Array of random letters? In the new action of the GamesController, create a new @letters instance variable storing these random letters from the alphabet. Then display it in the view. You should get something like this:



3 - Submitting a word
We need to add a form below the letters so that the user can fill a suggestion and submit it.

Go ahead and add a <form /> to your view. It should POST to the /score action in the GamesController. Remember about the :authenticity_token!



4 - At the other side of the form
Let's check that the form is being correctly set by inspecting what we get in params. They are two ways, the first one is to add raise in your controller code:

# app/controllers/games_controller.rb

# [...]
  def score
    raise
  end
  
Go to the /new page, fill a word and submit the form. You should get a RuntimeError from Rails, with a console at the bottom. You can type params to inspect what got sent:



The cleaner way is to add the pry-byebug gem (you can get rid of the default byebug one from rails new) and add binding.pry in your Controller code. This way you can pause the Rails request in the terminal, inspect, and type continue to let it go and finish rendering the view.

# Gemfile

# [...]
group :development, :test do
  # gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]
  gem 'pry-byebug'
end

You need bundle install and restart rails s for this change to take effect.

5 - Computing the score
Time to implement the GamesController#score logic. Do we have all the information at hand? What do we need? Do we need to pass more information through the POST request? Have a look at hidden_field_tag.

We want to handle three scenarios:

The word can't be built out of the original grid
The word is valid according to the grid, but is not a valid English word
The word is valid according to the grid and is an English word
(You can use this API to check if a word is valid.)

At the bottom of the results, add a link_to to go back to the New game page.

6 - Adding score (Optional)
The user will play many games, it makes sense to store each score and add it to a grand total. We can have a rule where the score for each game is the number of letters in every valid words (but you can be more creative, take the square of the number of letters? Something else?).

Today is not about the database, so we don't have ActiveRecord to help us store information and retrieve it between two HTTP requests. In Rails, another mechanisme exist to persist information accross HTTP requests: the session.

Try to use a Rails session to store, compute and display a grand score.

7 - Testing (Optional)
First, delete the test/controllers/games_controller_test.rb file if it got generated. We will be doing System Testing. The goal of this kind of testing is to automate all the manual testing of "code editing / go to the browser / reload the page / check if this is working". Everything you did manually in the browser can be done via code!

First, you need to make sure you have a recent version of Chrome on your system (not Chromium). It's available for both OSX and Ubuntu. Then you need to install chromedriver (if you did this step in the previous exercise, just skip it):

 # OSX
brew install chromedriver

# Ubuntu
gem install chromedriver-helper
We will use Headless Chrome for System Testing. It's a browser without a user interface, well-suited for this kind of automated tests. To do that, open the following file and replace all its content with:

# test/application_system_test_case.rb
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  Capybara.register_driver(:headless_chrome) do |app|
    capabilities = Selenium::WebDriver::Remote::Capabilities.chrome \
      chromeOptions: { args: %w[headless disable-gpu window-size=1280x760] }
    Capybara::Selenium::Driver.new app,
      browser: :chrome, desired_capabilities: capabilities
  end
  driven_by :headless_chrome
end

Ready? Let's dive into Rails Testing.

In the terminal, run the following to create the test file:

rails g system_test game
rails test:system # Should say 0 tests, and not fail
Great! We have a brand new file in test/system/games_test.rb! What do we want to test?

Going to the /new game page displays a random grid
You can fill the form with a random word, click the play button, and get a message that the word is not in the grid.
You can fill the form with a one-letter consonant word, click play, and get a message it's not a valid English word
You can fill the form with a valid English word (that's hard because there is randomness!), click play and get a "Congratulations" message
Let's do the first one together:

# test/system/games_test.rb
require "application_system_test_case"

class GamesTest < ApplicationSystemTestCase
  test "Going to /new gives us a new random grid to play with" do
    visit new_url
    assert test: "New game"
    assert_selector "li", count: 10
  end
end

In this test, I am visiting the /new URL and making sure I get ten letters to play with.

Now your turn! Try to implement the three other tests using Capybara fill_in and click_on methods.
